#include<iostream>
using namespace std;
/*
	剑指offer p41 面试题3：数组中重复的数字
	题目二：不修改数组找出重复的数字
		在一个长度为n+1的数组里面的所有数字都在1~n你的范围内，所有数组中至少有一个数字是重复的。
		请找出数组中任意一个重复的数字，但不能修改输入的数组。
		例如，如果输入长度为8的数组{2,3,5,4,3,2,6,7}，那么对应的输出是重复的数字2或者3。
	解析：
			长度为n+1的数组存1~n的数字，这数组一定是存在重复数的，在设计算法时，不需要考虑是否存在重复数。 本题还有一个明确的要求就是不能修改数组。
			解决这道题，很容易就能想到通过创建一个新数组并赋值为0; 新数组的下标代表数值，存的值代表出现次数。一次遍历原数组将原数组的值作为新数组
		的下标，对应新数组的值++。 通过判断值是否大于1来确定是否是重复值。这个方案很容易实现，并且还能找出所有重复数，但是这个方案需要
		创建O（n）的辅助空间。
			再看看不用创建O（n）辅助空间的方案：①利用二分查找法的思想，我们对1~n的数字进行二分，判断1~(1+n)/2的数字在数组中出现的次数是否大于(1+n)/2,
		②大于的话继续对1~(1+n)/2进行上述步骤①；小于的话那就说明(1+n)/2+1~n的数字中肯定有重复的在数组中，对(1+n)/2+1~n进行上述步骤。③直到二分到一个数的
		时候，这个数就是重复的数。 这种方案的时间复杂度为O（nlogn）,空间复杂度为O（1），与第一种方案对比，相当于以时间换空间了。

	本程序采用第二种方案，只能找到一个重复数
			
*/
int n[8]={1,2,5,4,4,3,2,7};
int begin=1; //表示二分的开始
int end=7;//表示二分的结束
int center=(begin+end)/2;//表示二分的中间


void timefind(int a,int b){//进行查找有无重复值
	int count=0;
	int i=0;
	for(;i<8;i++){//遍历数组查找符合条件数的个数
		if(n[i]<=b&&n[i]>=a){
			count++;
		}
	}
	cout<<"count="<<count<<endl;
	if(count>b-a+1){ //true->让end=center  在折一半继续二分，遍历
		end=center;
		
	}else{//false->让begin=center+1 转向另一半进行二分，再遍历
		begin=center+1;
	}
	center=(end+begin)/2;
	cout<<begin<<"  "<<center<<endl;
}


void usetimefind(){

	while(end>begin){ //当开始数大于等于结束数时 结束循环
		cout<<"循环一次"<<endl;
		cout<<begin<<"  "<<center<<endl;
		timefind(begin,center);
	}
}

int main(void){
	usetimefind();
	cout<<end<<endl;//输出重复数
	return 0;
}