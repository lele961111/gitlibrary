#include<iostream>
#include<string>
#include<stack>
using namespace std;

/*
	把只包含因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含因子7。 
	习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数
解析：首先分析一下所有的丑数都是只能由2,3,5进行任意乘积所得的，也就是说丑数是由丑数乘丑数得的。那么我用一个数组存放从小到大的所有丑数，那么数组后边的值就是前边两个相乘所得，
	又因为丑数的因子都是2,3,5，所以用2,3,5进行乘数组里的每个值就可得到所有的丑数。
    解题步骤：1 2 3 4 5 6 8 9 10 12 15 16 18 20 24 25 27 30 
	 2 * k1           3 4 5 5 6  8  8  9  10 12 15 15 15 16
	 3 * k2           3 3 3 4 4  5  6  6  8  8  9  9  10 12
	 5 * k2           5 5 5 5 5  5  5  5  5  5  5  6  6  8
	2从3开始是因为4已经写入了； 2,3,5乘的都是上边数组遍历得的
*/

void print(){
	cout<<"请输入要的丑数的个数："<<endl;
	int n;
	cin>>n;
	if(n<=0){
		cout<<"输入错误"<<endl;
		return;
	}
	int* a=(int*)malloc(sizeof(int)*(5+n)); //数组存放每个丑数 从小到大
	a[0]=1;
	a[1]=2;
	a[2]=3;
	a[3]=4;
	a[4]=5;  //为了数组中的丑数递增，将前5个数据放里边，也利于后边计算方便。
	int i;
	int k1=2,k2=2,k3=4;  //k1代表2*a[k1]的下标  k2代表3*a[k2]的下标   k3代表5*a[k3]的下标
	for(i=0;i<n;i++){
		a[i+5]=2*k1<3*k2?2*k1<5*k3?2*k1:5*k3:3*k2<5*k3?3*k2:5*k3;// 将最小值放入数组中
		if(2*a[k1]<=3*a[k2]){
			if(2*a[k1]<=5*a[k3]){
				a[i+5]=2*a[k1];
				k1++;
				k2=3*a[k2]==a[i+5]?k2+1:k2; //这里来判断其他两个算出的值是否有一样的，一样的就不用插入了，直接跳过，小于是不可能的，因为a[i+5]已经是三个数里最小的
				k3=5*a[k3]==a[i+5]?k3+1:k3;
			}else{
				a[i+5]=5*a[k3];
				k3++;
				k2=3*a[k2]==a[i+5]?k2+1:k2;
				k1=2*a[k1]==a[i+5]?k1+1:k1;
			}
		}else{
			if(3*a[k2]<=5*a[k3]){
				a[i+5]=3*a[k2];
				k2++;
				k1=2*a[k1]==a[i+5]?k1+1:k1;
				k3=5*a[k3]==a[i+5]?k3+1:k3;
			}else{
				a[i+5]=5*a[k3];
				k3++;
				k2=3*a[k2]==a[i+5]?k2+1:k2;
				k1=2*a[k1]==a[i+5]?k1+1:k1;
			}
		}
		cout<<"a["<<i+5<<"]="<<a[i+5]<<endl;						
	}
	for(i=0;i<n;i++){
		cout<<a[i]<<" ";
	}
	cout<<endl;
	
}
int main(void){
	print();
	return 0;
}




