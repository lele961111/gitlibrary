#include<iostream>
#include<math.h>
using namespace std;

/*
	设有n个正整数，将他们连接成一排，组成一个最大的多位整数。
	如:n=3时，3个整数13,312,343,连成的最大整数为34331213。
	如:n=4时,4个整数7,13,4,246连接成的最大整数为7424613。
	解析：
		第一步：先对每一个整数的前边第一位进行比较，大的排前边，小的排后边，当出现相等时 进入第二步
		第二步：比较第二位的数值，这个要复杂些，要考虑一个数有第二位，一个数没有第二位（如：7和71）这里有两种可能 分到第三步说，或者第二位又相等（如：771和77）进入第四步
		第三步：一种是有第二位的数小于另一个数，则一位数的大，否则另一个大，进入第四步
		第四步：第二步是个写死的，需要进行泛化，是相对的第二位，而不是绝对的第二位。
		优化解决：
			由上述步骤可以知道，一个数放在另一个数的前边条件就是：①第一位大于 ②第一位等于，进行下一位比较，大的在前边 ③ 当一个数没有下一位了，那么就用最后一位和下一位比较
		
		  根本上就是对每一位进行比较，如：7 774 我们可以将 7 看成 777 用777 和774进行比较，  将多个条件合并成一个条件，只需判读对应位数值的大小即可。


*/

int n=0;
int *a,*b; //a数组存储原数值 
int max=1;  //表示数值方面最大数值的位数
void init(){//初始化数组并记录最高位数
	cout<<"请输入数组长度："<<endl;
	cin>>n;
	cout<<"请输入"<<n<<"个整数"<<endl;
	a=(int *)malloc(n*sizeof(int));
	b=(int *)malloc(n*sizeof(int));
	for(int i=0;i<n;i++){
		cin>>a[i];
		while((int)(a[i]/pow(10,max))){ //减少循环
			max++;
		}
	}
}
void change(){ //将每个数都转换成同位数且缺位的补最后一位有效值
	for(int i=0;i<n;i++){
		int k=max-1;
		int temp=0;
		while(!(int)(a[i]/pow(10,k))){   //先算要增加的数 如23--->2333   先得到33   分两步  先得到11  后再乘a[i]%10 得33
			temp+=pow(10,max-k-1);
			k--;
		}
		b[i]=temp*(a[i]%10)+a[i]*pow(10,max-k-1);  //将原值进行乘缺少的位数再加先前计算的  得到的就是最终要的值
	}
}

//进行排序就可以

void print(){
	cout<<"开始输出"<<endl;
	for(int i=0;i<n-1;i++){
		int temp;
		for(int j=i+1;j<n;j++){
			if(b[i]<b[j]){
				temp=a[i];
				a[i]=a[j];
				a[j]=temp;
				temp=b[i];
				b[i]=b[j];
				b[j]=temp;
			}
		}
		cout<<a[i];
	}
	cout<<a[n-1];
	cout<<endl;
	cout<<"输出结束"<<endl;
}

int main(void){
	init();
	change();
	print();
	return 0;
}

